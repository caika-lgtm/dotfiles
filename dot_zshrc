export ZSH="$HOME/.oh-my-zsh"
export FZF_BASE=/usr/local/bin/fzf
ZSH_THEME=""
COMPLETION_WAITING_DOTS="true"
zvm_config() {
  ZVM_INSERT_MODE_CURSOR=$ZVM_CURSOR_BLINKING_UNDERLINE
}
plugins=(
  git
  branch
  colored-man-pages
  colorize
  zsh-syntax-highlighting
  zsh-autosuggestions
  zsh-vi-mode
  # fzf
  fzf-zsh-plugin
)
source $ZSH/oh-my-zsh.sh

export PATH=$HOME/go/bin:$PATH
export PATH="$PATH:/Users/SG3937/.local/bin"
# alias l="ls -la"
alias l='eza -lab --icons=auto --group-directories-first --smart-group --git --git-repos'
alias lt='eza -lab --icons=auto --group-directories-first --smart-group --git --git-repos -T -L 2'
alias lt='eza -lab --icons=auto --group-directories-first --smart-group --git --git-repos -T -L 3'
export EDITOR='nvim'
# alias nap="EDITOR=nvim nap"
alias checkout='fzf-git-checkout && g pull'
# emodipt-extend, kali, stelbent.minimal
eval "$(oh-my-posh init zsh --config ~/.mytheme.omp.json)"

zvm_after_init_commands+=('[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh')

export FZF_PREVIEW_ADVANCED=1
export FZF_PREVIEW_COMMAND="bat --style=numbers,changes --wrap never --color always {} || cat {} || tree -C {}"
export FZF_COMMON_OPTIONS="
  --bind='?:toggle-preview'
  --bind='ctrl-u:preview-page-up'
  --bind='ctrl-d:preview-page-down'
  --preview '([[ -d {} ]] && tree -C {}) || ([[ -f {} ]] && bat --style=full --color=always {}) || echo {}'
  --color=fg:-1,fg+:#d0d0d0,bg:-1,bg+:#262626
  --color=hl:#5f87af,hl+:#5fd7ff,info:#afaf87,marker:#87ff00
  --color=prompt:#d7005f,spinner:#af5fff,pointer:#af5fff,header:#87afaf
  --color=border:#262626,label:#aeaeae,query:#d9d9d9
  --border='thinblock' --border-label='' --preview-window='border-rounded' --padding=0
  --prompt='> ' --marker='>' --pointer='â—†' --separator='â”€'
  --scrollbar='â”‚' --layout='reverse' --info='right'"

command -v fd > /dev/null && export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git'
command -v bat > /dev/null && command -v tree > /dev/null && export FZF_DEFAULT_OPTS="$FZF_COMMON_OPTIONS"
command -v fd > /dev/null && export FZF_ALT_C_COMMAND='fd --type d --hidden --follow --exclude .git'
command -v fd > /dev/null && export FZF_CTRL_T_COMMAND='fd --type f --type d --hidden --follow --exclude .git'

source <(fzf --zsh)

rundev() {
    local container_name="infra-center-dev-container"
    local workdir="/var/www/infra-center"
    docker exec -it "$container_name" sh -c "cd $workdir && $*"
}

enterdev() {
    local container_name="infra-center-dev-container"
    local workdir="/var/www/infra-center"
    echo "cd $workdir" | pbcopy
    docker exec -it "$container_name" bash
}

devc() {
    local type="$1"  # 'feat', 'fix', for e.g.
    local message="$2"
    local branch_name=$(git rev-parse --abbrev-ref HEAD)
    local ticket_id=$(echo "$branch_name" | grep -oE '[A-Z]+-[0-9]+')

    if [[ -z "$ticket_id" ]]; then
      echo "ðŸ˜¢ No ticket ID found in branch name. Aborting commit."
      return 1 
    fi

    local formatted_message="$type: [$ticket_id] $message"
    echo "ðŸŽ‰ Committing with message: \"$formatted_message\""
    # rundev git commit --verbose -m "'$formatted_message'"
    git commit --verbose -m "$formatted_message"
  }

cfeat() {
  devc "feat" "$1"
}

cfix() {
  devc "fix" "$1"
}

cchore() {
  devc "chore" "$1"
}

crefactor() {
  devc "refactor" "$1"
}

# alias gca='rundev git commit --verbose --all --date=now --no-edit --amend'
alias gca='git commit --verbose --all --date=now --no-edit --amend'
alias pre="rundev 'poetry run mycli -h infra_center_db -P 3306 -u root -proot -e \"drop database infra_center_db; create database infra_center_db\" && poetry run alembic upgrade head'"

export LESSOPEN="|/opt/homebrew/bin/lesspipe.sh %s"
alias editzshrc='chezmoi edit ~/.zshrc && chezmoi apply'
alias vim='nvim'

export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init --path)"
eval "$(pyenv init -)" 

export NAP_CONFIG="~/.nap/config.yaml"
export NAP_HOME="~/.nap"

unalias gg 2>/dev/null

mr_create() {
  local target_branch mr_output mr_url

  target_branch=$(
    git branch --format='%(refname:short)' \
      | fzf --prompt="Target branch > "  --height=40% --layout=reverse --border
    )
    if [[ -z "$target_branch" ]]; then
      echo "No target branch selected."
      return 1
    fi

    mr_output=$(glab mr create -a @me -f -l "ReadyForReview ðŸ‘€" -b "$target_branch")
    echo "$mr_output"

    mr_url=$(echo "$mr_output" | rg -o 'https?://[^ ]+/merge_requests/[0-9]+' | tail -n 1)
    if [[ -n "$mr_url" ]]; then
      echo -n "$mr_url" | pbcopy
      echo "MR URL copied to clipboard."
    else
      echo "MR URL not found in output."
      return 1
    fi
}


mr_view() {
  glab mr view "${1:-$(g branch --show-current)}" -w
}

mrs() {
    local jq_filter
    jq_filter='
      .[] | [
        (.iid|tostring),
        .source_branch,
        .target_branch,
        ((.labels | map(select(test("release|improvement|review"; "i"))) | if length==0 then "-" else join(", ") end)),
        .detailed_merge_status,
        .state,
        (.updated_at as $t
          | ($t | sub("\\.[0-9]+";"")) as $t
          | ($t[0:-3] + $t[-2:])
          | strptime("%Y-%m-%dT%H:%M:%S%z")
          | mktime
          | strftime("%d %b %I:%M%p")
          | sub("^0";"")
          | sub(" 0";" ")
        )
      ] | @tsv
    '
      local awk_fmt
      awk_fmt='
      function pad(s, w) {
        padlen = w - length(s)
        if (padlen < 0) padlen = 0
        padstr = sprintf("%*s", padlen, "")
        gsub(/ /, ".", padstr)
        return s GRAY padstr RESET
      }
      function ruler(n, ch) {
        s = sprintf("%*s", n, "")
        gsub(/ /, ch, s)
        return s
      }
      {
        split($0, f, "\t")
        iid="!" f[1]
        src=f[2]
        tgt=f[3]
        label=f[4]
        status=f[5]
        state=f[6]
        updated=f[7]
        status_state = state " (" status ")"

        r1[NR]=iid; r2[NR]=src; r3[NR]=tgt; r4[NR]=label; r5[NR]=status_state; r6[NR]=updated
        s5[NR]=status; s6[NR]=state; lab[NR]=label

        if (length(r1[NR])>w[1]) w[1]=length(r1[NR])
        if (length(r2[NR])>w[2]) w[2]=length(r2[NR])
        if (length(r3[NR])>w[3]) w[3]=length(r3[NR])
        if (length(r4[NR])>w[4]) w[4]=length(r4[NR])
        if (length(r5[NR])>w[5]) w[5]=length(r5[NR])
        if (length(r6[NR])>w[6]) w[6]=length(r6[NR])
      }
      END {
        ORANGE="\033[38;5;208m"
        GREEN="\033[0;32m"
        WHITE="\033[0;37m"
        PURPLE="\033[0;35m"
        GRAY="\033[0;90m"
        RESET="\033[0m"
      
        sep_done=0
        for (r=1;r<=NR;r++) {
          label_color = (lab[r] ~ /WaitingForImprovement/) ? "\033[0;31m" : "\033[0;32m"

          status=s5[r]
          state=s6[r]
          if (status ~ /^(mergeable|ci_must_pass)$/) status_color=GREEN
          else if (status ~ /^(conflicts|ci_failed|approval_needed|not_approved|draft_status|blocked_status|policies_denied|external_status_checks|broken_status)$/) status_color=ORANGE
          else status_color=WHITE
          if (state == "merged") status_color=GRAY

          if (state == "merged" && !sep_done) {
            width = w[1]+1 + w[2] + w[3] + w[4] + w[5] + w[6] + 5
            printf "%s%s%s\n", GRAY, ruler(width, "-"), RESET
            sep_done=1
          }

          printf "\033[0;37m%s\033[0m \033[0;33m%s\033[0m %s%s\033[0m %s%s\033[0m %s%s\033[0m %s%s\033[0m\n",
            pad(r1[r], w[1]+1),
            pad(r2[r], w[2]),
            PURPLE, pad(r3[r], w[3]),
            label_color, pad(r4[r], w[4]),
            status_color, pad(r5[r], w[5]),
            WHITE, pad(r6[r], w[6])
        }
      }
      '

    local -a args=()
    local all=0
    for arg in "$@"; do
      if [[ $arg == -A ]]; then
        all=1
      else
        args+=("$arg")
      fi
    done

    if (( all )); then
      jq -s '.[0] + .[1]' \
        <(glab mr list --author @me -F json -o updated_at -S desc "${args[@]}") \
        <(glab mr list --author @me -F json -o updated_at -S desc -M "${args[@]}") \
      | jq -r "$jq_filter" | awk -F '\t' "$awk_fmt"
    else
      glab mr list --author @me -F json -o updated_at -S desc "${args[@]}" \
      | jq -r "$jq_filter" | awk -F '\t' "$awk_fmt"
    fi
  }

_ci_status_parse() {
  jq -r '
  def dur(s):
  if s == null then ""
  else
    (s | floor) as $t
    | ($t / 3600 | floor) as $h
    | ($t % 3600 / 60 | floor) as $m
    | ($t % 60) as $sec
    | if $h > 0 then
    "\($h)h" + (if $m < 10 then "0" else "" end) + "\($m)m" + (if $sec < 10 then "0" else "" end) + "\($sec)s"
  else
    "\($m)m\($sec)s"
  end
end;

{
  pipeline_id: .id,
  pipeline_status: .status,
  user_username: .user.username,
  finished_at: .finished_at,
  jobs: (.jobs // [] | map({
    commit_short_id: .commit.short_id,
    job_name: .name,
    job_id: .id,
    job_status: .status,
    job_duration: dur(.duration),
    job_failure_reason: .failure_reason
  }))
}'
}

_ci_status_format_line() {
  jq -r '
  def status_emoji(s):
  if s == "failed" then "ðŸ˜ž"
  elif s == "success" then "ðŸŽ‰"
  else "â³"
  end;

  def normalize_ts:
  .
  | sub("\\.[0-9]+"; "")
  | if test("([+-][0-9]{2}):([0-9]{2})$") then
  (capture("^(?<base>.*)(?<tz>[+-][0-9]{2}):(?<tzm>[0-9]{2})$") | "\(.base)\(.tz)\(.tzm)")
else
  .
end;

def finished_label(x):
if x == null then ""
else
  (" finished at " + (
    x
    | normalize_ts
    | strptime("%Y-%m-%dT%H:%M:%S%z")
    | mktime
    | strftime("%d %b %I:%M%p")
    | sub("^0";"")
    | sub(" 0";" ")
    | ascii_upcase
    ))
  end;

  def commit_short:
  if (.jobs | length) > 0 then .jobs[0].commit_short_id else null end;

    "Pipeline \(.pipeline_id) \(.pipeline_status) \(status_emoji(.pipeline_status)) triggered by @\(.user_username) for \(commit_short)\(finished_label(.finished_at))."
    '
  }

_ci_status_colorize() {
  local line
  while IFS= read -r line; do
    if [[ $line =~ '^Pipeline ([0-9]+) ([^ ]+) ([^ ]+) triggered by @([^ ]+) for ([^ ]+)( finished at (.+))?\.$' ]]; then
      local id="${match[1]}"
      local status_text="${match[2]}"
      local emoji="${match[3]}"
      local user="${match[4]}"
      local sha="${match[5]}"
      local finished="${match[7]}"

      local purple='%F{magenta}'
      local highlight='%F{yellow}'
      local reset='%f'

      local status_color
      case "$status_text" in
        success) status_color='%F{green}' ;;
        failed) status_color='%F{red}' ;;
        *) status_color='%F{yellow}' ;;
      esac

      local out="Pipeline ${purple}${id}${reset} ${status_color}${status_text}${reset} ${emoji} (triggered by @${highlight}${user}${reset} for ${highlight}${sha}${reset}"
      if [[ -n "$finished" ]]; then
        out+=" finished at ${highlight}${finished}${reset})"
      else
        out+=")"
      fi

      print -P -- "$out"
    else
      print -r -- "$line"
    fi
  done
}

_ci_status_jobs_table_pretty() {
  jq -r '
  def status_text(j):
  if j.job_status == "skipped" then "skipped"
  elif j.job_status == "success" then "success in \((j.job_duration // ""))"
  elif j.job_status == "failed" then
    "failed in \((j.job_duration // ""))" +
    (if (j.job_failure_reason // "") != "" then " (\(j.job_failure_reason))" else "" end)
  else
    j.job_status
  end;

  (.jobs[] | [(.job_id|tostring), .job_name, status_text(.)] | @tsv)
  ' | awk -F '\t' '
  {
    id[NR]=$1; name[NR]=$2; status[NR]=$3;
    if (length($1)>w1) w1=length($1);
      if (length($2)>w2) w2=length($2);
      }
  END{
    purple="\033[35m"; yellow="\033[33m"; red="\033[31m";
    green="\033[32m"; gray="\033[90m"; reset="\033[0m";
    for (i=1;i<=NR;i++){
      s=status[i];
      if (s ~ /^failed/) c=red;
      else if (s ~ /^success/) c=green;
      else if (s ~ /^skipped/) c=gray;
      else c=reset;
        printf "%s%-*s%s  %s%-*s%s  %s%s%s\n",
        purple, w1, id[i], reset,
        yellow, w2, name[i], reset,
        c, s, reset;
      }
  }
'
}

_ci_status_for_branch() {
  local branch="$1"
  [[ -n "$branch" ]] || return 1

  print -P -- "Showing CI status for branch %F{magenta}$branch%f"

  local json
  json="$(glab ci get -d -F json -b "$branch")" || return 1

  print -r -- "$json" | _ci_status_parse | _ci_status_format_line | _ci_status_colorize
  print -r -- "$json" | _ci_status_parse | _ci_status_jobs_table_pretty

  local failed_job_id
  failed_job_id="$(
    print -r -- "$json" \
      | _ci_status_parse \
      | jq -r '.jobs[] | select(.job_status=="failed") | .job_id' \
      | head -n 1
    )"

    if [[ -n "$failed_job_id" ]]; then
      print -n -- "$failed_job_id" | pbcopy
      print -P -- "\n%F{yellow}Copied failed job id to clipboard:%f %F{magenta}$failed_job_id%f"
    fi
  }


ci_status() {
  local branch
  branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)" || return 1
  _ci_status_for_branch "$branch"
}

ci_status_for() {
  local branch
  branch="$(
    git for-each-ref --format='%(refname:short)' refs/heads refs/remotes \
      | sed 's#^origin/##' \
      | grep -v '^origin/HEAD$' \
      | sort -u \
      | fzf --prompt='Branch > ' --height=40% --layout=reverse --border
    )" || return 1
    _ci_status_for_branch "$branch"
  }

ci_trace() {
  local job_id="$1"
  [[ -n "$job_id" ]] || { print -r -- "usage: ci_trace <job_id>"; return 1; }

  glab ci trace "$job_id" \
    | awk -v gray="\033[90m" -v reset="\033[0m" '
  {
    line = $0
    while (match(line, /section_(start|end):[0-9]+:[^[:space:]]+/)) {
      pre = substr(line, 1, RSTART - 1)
      token = substr(line, RSTART, RLENGTH)
      post = substr(line, RSTART + RLENGTH)
      if (pre != "") print pre
        split(token, a, ":")
        type = a[1]; name = a[3]
        if (type == "section_start") print gray "==> START " name reset
        else print gray "<== END " name reset
          line = post
        }
      if (line != "") print line
      }
    ' | bat --pager="less -FR +G"
}
