export ZSH="$HOME/.oh-my-zsh"
export FZF_BASE=/usr/local/bin/fzf
ZSH_THEME=""
COMPLETION_WAITING_DOTS="true"
zvm_config() {
    ZVM_INSERT_MODE_CURSOR=$ZVM_CURSOR_BLINKING_UNDERLINE
}
plugins=(
    git
    branch
    colored-man-pages
    colorize
    zsh-syntax-highlighting
    zsh-autosuggestions
    zsh-vi-mode
    # fzf
    fzf-zsh-plugin
)
source $ZSH/oh-my-zsh.sh

export PATH=$HOME/go/bin:$PATH
export PATH="$PATH:/Users/SG3937/.local/bin"
export PATH="/opt/homebrew/opt/mysql-client/bin:$PATH"

unalias gg 2>/dev/null
unalias gl 2>/dev/null
unalias gr 2>/dev/null
unalias grs 2>/dev/null
unalias l 2>/dev/null

# alias l="ls -la"
eza_base() {
    setopt local_options GLOB_DOTS NULL_GLOB
    eza --icons=auto --group-directories-first --smart-group --git "$@"
}

l()    { eza_base -la "$@"; }
lt()   { eza_base -la -T -L 2 "$@"; }
ltt()  { eza_base -la -T -L 3 "$@"; }

lh()   { eza_base -lb "$@"; }
lht()  { eza_base -lb -T -L 2 "$@"; }
lhtt() { eza_base -lb -T -L 3 "$@"; }

lH()   { eza_base -lb --git-ignore "$@"; }
lHt()  { eza_base -lb -T -L 2 --git-ignore "$@"; }
lHtt() { eza_base -lb -T -L 3 --git-ignore "$@"; }

li()   { eza_base -la --git-ignore "$@"; }
lit()  { eza_base -la -T -L 2 --git-ignore "$@"; }
litt() { eza_base -la -T -L 3 --git-ignore "$@"; }

alias gr="git restore ."
alias grs="git restore --staged ."


export EDITOR='nvim'
# alias nap="EDITOR=nvim nap"
alias checkout='fzf-git-checkout && g pull'
# emodipt-extend, kali, stelbent.minimal
eval "$(oh-my-posh init zsh --config ~/.mytheme.omp.json)"

zvm_after_init_commands+=('[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh')

export FZF_PREVIEW_ADVANCED=1
export FZF_PREVIEW_COMMAND="bat --style=numbers,changes --wrap never --color always {} || cat {} || tree -C {}"
export FZF_COMMON_OPTIONS="
  --bind='?:toggle-preview'
  --bind='ctrl-u:preview-page-up'
  --bind='ctrl-d:preview-page-down'
  --preview '([[ -d {} ]] && tree -C {}) || ([[ -f {} ]] && bat --style=full --color=always {}) || echo {}'
  --color=fg:-1,fg+:#d0d0d0,bg:-1,bg+:#262626
  --color=hl:#5f87af,hl+:#5fd7ff,info:#afaf87,marker:#87ff00
  --color=prompt:#d7005f,spinner:#af5fff,pointer:#af5fff,header:#87afaf
  --color=border:#262626,label:#aeaeae,query:#d9d9d9
  --border='thinblock' --border-label='' --preview-window='border-rounded' --padding=0
  --prompt='> ' --marker='>' --pointer='‚óÜ' --separator='‚îÄ'
  --scrollbar='‚îÇ' --layout='reverse' --info='right'"

command -v fd > /dev/null && export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git'
command -v bat > /dev/null && command -v tree > /dev/null && export FZF_DEFAULT_OPTS="$FZF_COMMON_OPTIONS"
command -v fd > /dev/null && export FZF_ALT_C_COMMAND='fd --type d --hidden --follow --exclude .git'
command -v fd > /dev/null && export FZF_CTRL_T_COMMAND='fd --type f --type d --hidden --follow --exclude .git'

source <(fzf --zsh)

rundev() {
    local container_name="infra-center-dev-container"
    local workdir = "/var/www/infra-center"
    docker exec -it "$container_name" sh -c "cd $workdir && $*"
}

enterdev() {
    local container_name="infra-center-dev-container"
    local workdir="/var/www/infra-center"
    echo "cd $workdir" | pbcopy
    docker exec -it "$container_name" bash
}

devc() {
    local type="$1"  # 'feat', 'fix', for e.g.
    local message="$2"
    local branch_name=$(git rev-parse --abbrev-ref HEAD)
    local ticket_id=$(echo "$branch_name" | grep -oE '[A-Z]+-[0-9]+')

    if [[ -z "$ticket_id" ]]; then
        echo "üò¢ No ticket ID found in branch name. Aborting commit."
        return 1
    fi

    local formatted_message="$type: [$ticket_id] $message"
    echo "üéâ Committing with message: \"$formatted_message\""
    # rundev git commit --verbose -m "'$formatted_message'"
    git commit --verbose -m "$formatted_message"
}

cfeat() {
    devc "feat" "$1"
}

cfix() {
    devc "fix" "$1"
}

cchore() {
    devc "chore" "$1"
}

crefactor() {
    devc "refactor" "$1"
}

# alias gca='rundev git commit --verbose --all --date=now --no-edit --amend'
alias gca='git commit --verbose --all --date=now --no-edit --amend'
alias pre="poetry run mycli -h localhost -P 3306 -u root -proot -e \"drop database infra_center_db; create database infra_center_db\" && poetry run alembic upgrade head"

export LESSOPEN="|/opt/homebrew/bin/lesspipe.sh %s"
alias editzshrc='chezmoi edit ~/.zshrc && chezmoi apply'
alias vim='nvim'

export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init --path)"
eval "$(pyenv init -)"

export NAP_CONFIG="~/.nap/config.yaml"
export NAP_HOME="~/.nap"


mr-create() {
    git push
    local target_branch mr_output mr_url

    target_branch=$(
        git branch --format='%(refname:short)' \
            | fzf --prompt="Target branch > "  --height=40% --layout=reverse --border
    )
    if [[ -z "$target_branch" ]]; then
        echo "No target branch selected."
        return 1
    fi

    mr_output=$(glab mr create -a @me -f -l "ReadyForReview üëÄ" -b "$target_branch")
    echo "$mr_output"

    mr_url=$(echo "$mr_output" | rg -o 'https?://[^ ]+/merge_requests/[0-9]+' | tail -n 1)
    if [[ -n "$mr_url" ]]; then
        echo -n "$mr_url" | pbcopy
        echo "MR URL copied to clipboard."
    else
        echo "MR URL not found in output."
        return 1
    fi
}


mr-view() {
    glab mr view "${1:-$(g branch --show-current)}" -w
}

mr-rebase() {
    local branch
    branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)" || return 1
    if [[ -z "$branch" || "$branch" == "HEAD" ]]; then
        echo "mr_rebase: not on a branch" >&2
        return 1
    fi
    glab mr rebase "$branch"
}

mr-target() {
    local current_branch target_branch
    current_branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)" || return 1
    if [[ -z "$current_branch" || "$current_branch" == "HEAD" ]]; then
        echo "mr_target: not on a branch" >&2
        return 1
    fi

    target_branch="$(
    git for-each-ref --format='%(refname:short)' refs/heads/ \
      | fzf --prompt="Target branch > " --height=40% --layout=reverse --border
  )" || return 1

    if [[ -z "$target_branch" ]]; then
        echo "mr_target: no target branch selected" >&2
        return 1
    fi

    glab mr update "$current_branch" --target-branch "$target_branch"
}

ci-status-short() {
    local branch="$1"
    if [[ -z "$branch" ]]; then
        echo "usage: ci-status-short <branch>"
        return 1
    fi

    local output pipe_status stages red reset
    red=$'\e[31m'
    reset=$'\e[0m'

    output="$(glab ci get -b "$branch" -d 2>/dev/null)" || {
        echo "üîç"
        return 1
    }

    pipe_status="$(printf "%s\n" "$output" | awk -F: '/^status:/ {gsub(/^[ \t]+/, "", $2); print $2; exit}')"

    if [[ "$pipe_status" == "failed" ]]; then
        stages=("${(@f)$(printf "%s\n" "$output" \
        | awk '
            BEGIN {in_jobs=0}
            /^# Jobs:/ {in_jobs=1; next}
            in_jobs && /^ID[[:space:]]+Name/ {next}
            in_jobs {
              for (i=1; i<=NF; i++) {
                if ($i ~ /^(failed|success|skipped|running|pending)$/) {
                  status_text=$i
                  name=""
                  for (j=2; j<i; j++) {
                    name = name (j==2 ? "" : " ") $j
                  }
                  if (status_text=="failed") {
                    sub(/:.*/, "", name)
                    print name
                  }
                  break
                }
              }
            }' \
        | awk '!seen[$0]++'
      )}")

        if (( ${#stages[@]} > 0 )); then
            echo "${red}üëé (${(j:, :)stages})${reset}"
        else
            echo "${red}üëé${reset}"
        fi
    elif [[ "$pipe_status" == "success" ]]; then
        echo "üéâ"
    elif [[ "$pipe_status" == "pending" ]]; then
        echo "üôè"
    elif [[ "$pipe_status" == "running" ]]; then
        echo "üèÉ"
    elif [[ "$pipe_status" == "canceled" ]]; then
        echo "üö´"
    elif [[ "$pipe_status" == "skipped" ]]; then
        echo "‚è≠Ô∏è"
    elif [[ "$pipe_status" == "created" ]]; then
        echo "üöß"
    elif [[ "$pipe_status" == "manual" ]]; then
        echo "üìù"
    elif [[ "$pipe_status" == "waiting_for_resource" ]]; then
        echo "üí§"
    elif [[ "$pipe_status" == "preparing" ]]; then
        echo "‚è≥"
    elif [[ "$pipe_status" == "scheduled" ]]; then
        echo "üìÖ"
    else
        echo "‚ùì"
    fi
}

mrs() {
    local jq_filter
    jq_filter='
      .[] | [
        (.iid|tostring),
        .source_branch,
        .target_branch,
        ((.labels | map(select(test("release|improvement|review"; "i"))) | if length==0 then "-" else join(", ") end)),
        .detailed_merge_status,
        .state,
        (.updated_at as $t
          | ($t | sub("\\.[0-9]+";"")) as $t
          | ($t[0:-3] + $t[-2:])
          | strptime("%Y-%m-%dT%H:%M:%S%z")
          | mktime
          | strftime("%d %b %I:%M%p")
          | sub("^0";"")
          | sub(" 0";" ")
        )
      ] | @tsv
    '
    local awk_fmt
    awk_fmt='
      function strip_ansi(s, t) {
        t = s
        gsub(/\033\[[0-9;]*m/, "", t)
        return t
      }
      function vislen(s) {
        return length(strip_ansi(s))
      }
      function pad(s, w) {
        padlen = w - vislen(s)
        if (padlen < 0) padlen = 0
        padstr = sprintf("%*s", padlen, "")
        gsub(/ /, ".", padstr)
        return s GRAY padstr RESET
      }
      function ruler(n, ch) {
        s = sprintf("%*s", n, "")
        gsub(/ /, ch, s)
        return s
      }
      {
        split($0, f, "\t")
        iid="!" f[1]
        src=f[2]
        tgt=f[3]
        label=f[4]
        status=f[5]
        state=f[6]
        pipe=f[7]
        updated=f[8]
        status_state = state " (" status ")"

        r1[NR]=iid; r2[NR]=src; r3[NR]=tgt; r4[NR]=label; r5[NR]=status_state; r6[NR]=pipe; r7[NR]=updated
        s5[NR]=status; s6[NR]=state; lab[NR]=label

        if (vislen(r1[NR])>w[1]) w[1]=vislen(r1[NR])
        if (vislen(r2[NR])>w[2]) w[2]=vislen(r2[NR])
        if (vislen(r3[NR])>w[3]) w[3]=vislen(r3[NR])
        if (vislen(r4[NR])>w[4]) w[4]=vislen(r4[NR])
        if (vislen(r5[NR])>w[5]) w[5]=vislen(r5[NR])
        if (vislen(r6[NR])>w[6]) w[6]=vislen(r6[NR])
        if (vislen(r7[NR])>w[7]) w[7]=vislen(r7[NR])
      }
      END {
        ORANGE="\033[38;5;208m"
        GREEN="\033[0;32m"
        WHITE="\033[0;37m"
        PURPLE="\033[0;35m"
        GRAY="\033[0;90m"
        RESET="\033[0m"

        sep_done=0
        for (r=1;r<=NR;r++) {
          label_color = (lab[r] ~ /WaitingForImprovement/) ? "\033[0;31m" : "\033[0;32m"

          status=s5[r]
          state=s6[r]
          if (status ~ /^(mergeable|ci_must_pass)$/) status_color=GREEN
          else if (status ~ /^(conflicts|ci_failed|approval_needed|not_approved|draft_status|blocked_status|policies_denied|external_status_checks|broken_status)$/) status_color=ORANGE
          else status_color=WHITE
          if (state == "merged") status_color=GRAY

          if (state == "merged" && !sep_done) {
            width = w[1]+1 + w[2] + w[3] + w[4] + w[5] + w[6] + w[7] + 6
            printf "%s%s%s\n", GRAY, ruler(width, "-"), RESET
            sep_done=1
          }

          printf "\033[0;37m%s\033[0m \033[0;33m%s\033[0m %s%s\033[0m %s%s\033[0m %s%s\033[0m %s%s\033[0m %s%s\033[0m\n",
            pad(r1[r], w[1]+1),
            pad(r2[r], w[2]),
            PURPLE, pad(r3[r], w[3]),
            label_color, pad(r4[r], w[4]),
            status_color, pad(r5[r], w[5]),
            WHITE, pad(r6[r], w[6]),
            WHITE, pad(r7[r], w[7])
        }
      }
      '

    local -a args=()
    local all=0
    for arg in "$@"; do
        if [[ $arg == -A ]]; then
            all=1
        else
            args+=("$arg")
        fi
    done

    if (( all )); then
        jq -s '.[0] + .[1]' \
            <(glab mr list --author @me -F json -o updated_at -S desc "${args[@]}") \
            <(glab mr list --author @me -F json -o updated_at -S desc -M -P 10 "${args[@]}") \
            | jq -r "$jq_filter" \
            | {
            while IFS=$'\t' read -r iid src tgt label merge_status state updated; do
                pipe=$(ci-status-short "$src")
                printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' \
                    "$iid" "$src" "$tgt" "$label" "$merge_status" "$state" "$pipe" "$updated"
            done
        } | awk -F $'\t' "$awk_fmt"
    else
        glab mr list --author @me -F json -o updated_at -S desc "${args[@]}" \
            | jq -r "$jq_filter" \
            | {
            while IFS=$'\t' read -r iid src tgt label merge_status state updated; do
                pipe=$(ci-status-short "$src")
                printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' \
                    "$iid" "$src" "$tgt" "$label" "$merge_status" "$state" "$pipe" "$updated"
            done
        } | awk -F $'\t' "$awk_fmt"
    fi
}

_ci_status_parse() {
    jq -r '
  def dur(s):
  if s == null then ""
  else
    (s | floor) as $t
    | ($t / 3600 | floor) as $h
    | ($t % 3600 / 60 | floor) as $m
    | ($t % 60) as $sec
    | if $h > 0 then
    "\($h)h" + (if $m < 10 then "0" else "" end) + "\($m)m" + (if $sec < 10 then "0" else "" end) + "\($sec)s"
  else
    "\($m)m\($sec)s"
  end
end;

{
  pipeline_id: .id,
  pipeline_status: .status,
  user_username: .user.username,
  finished_at: .finished_at,
  jobs: (.jobs // [] | map({
    commit_short_id: .commit.short_id,
    job_name: .name,
    job_id: .id,
    job_status: .status,
    job_duration: dur(.duration),
    job_failure_reason: .failure_reason
  }))
}'
}

_ci_status_format_line() {
    jq -r '
  def status_emoji(s):
  if s == "failed" then "üòû"
  elif s == "success" then "üéâ"
  else "‚è≥"
  end;

  def normalize_ts:
  .
  | sub("\\.[0-9]+"; "")
  | if test("([+-][0-9]{2}):([0-9]{2})$") then
  (capture("^(?<base>.*)(?<tz>[+-][0-9]{2}):(?<tzm>[0-9]{2})$") | "\(.base)\(.tz)\(.tzm)")
else
  .
end;

def finished_label(x):
if x == null then ""
else
  (" finished at " + (
    x
    | normalize_ts
    | strptime("%Y-%m-%dT%H:%M:%S%z")
    | mktime
    | strftime("%d %b %I:%M%p")
    | sub("^0";"")
    | sub(" 0";" ")
    | ascii_upcase
    ))
  end;

  def commit_short:
  if (.jobs | length) > 0 then .jobs[0].commit_short_id else null end;

    "Pipeline \(.pipeline_id) \(.pipeline_status) \(status_emoji(.pipeline_status)) triggered by @\(.user_username) for \(commit_short)\(finished_label(.finished_at))."
    '
}

_ci_status_colorize() {
    local line
    while IFS= read -r line; do
        if [[ $line =~ '^Pipeline ([0-9]+) ([^ ]+) ([^ ]+) triggered by @([^ ]+) for ([^ ]+)( finished at (.+))?\.$' ]]; then
            local id="${match[1]}"
            local status_text="${match[2]}"
            local emoji="${match[3]}"
            local user="${match[4]}"
            local sha="${match[5]}"
            local finished="${match[7]}"

            local purple='%F{magenta}'
            local highlight='%F{yellow}'
            local reset='%f'

            local status_color
            case "$status_text" in
                success) status_color='%F{green}' ;;
                failed) status_color='%F{red}' ;;
                *) status_color='%F{yellow}' ;;
            esac

            local out="Pipeline ${purple}${id}${reset} ${status_color}${status_text}${reset} ${emoji} (triggered by @${highlight}${user}${reset} for ${highlight}${sha}${reset}"
            if [[ -n "$finished" ]]; then
                out+=" finished at ${highlight}${finished}${reset})"
            else
                out+=")"
            fi

            print -P -- "$out"
        else
            print -r -- "$line"
        fi
    done
}

_ci_status_jobs_table_pretty() {
    jq -r '
  def status_text(j):
  if j.job_status == "skipped" then "skipped"
  elif j.job_status == "success" then "success in \((j.job_duration // ""))"
  elif j.job_status == "failed" then
    "failed in \((j.job_duration // ""))" +
    (if (j.job_failure_reason // "") != "" then " (\(j.job_failure_reason))" else "" end)
  else
    j.job_status
  end;

  (.jobs[] | [(.job_id|tostring), .job_name, status_text(.)] | @tsv)
  ' | awk -F '\t' '
  {
    id[NR]=$1; name[NR]=$2; status[NR]=$3;
    if (length($1)>w1) w1=length($1);
      if (length($2)>w2) w2=length($2);
      }
  END{
    purple="\033[35m"; yellow="\033[33m"; red="\033[31m";
    green="\033[32m"; gray="\033[90m"; reset="\033[0m";
    for (i=1;i<=NR;i++){
      s=status[i];
      if (s ~ /^failed/) c=red;
      else if (s ~ /^success/) c=green;
      else if (s ~ /^skipped/) c=gray;
      else c=reset;
        printf "%s%-*s%s  %s%-*s%s  %s%s%s\n",
        purple, w1, id[i], reset,
        yellow, w2, name[i], reset,
        c, s, reset;
      }
  }
'
}

_ci_status_for_branch() {
    local branch="$1"
    [[ -n "$branch" ]] || return 1

    print -P -- "Showing CI status for branch %F{magenta}$branch%f"

    local json
    json="$(glab ci get -d -F json -b "$branch")" || return 1

    print -r -- "$json" | _ci_status_parse | _ci_status_format_line | _ci_status_colorize
    print -r -- "$json" | _ci_status_parse | _ci_status_jobs_table_pretty

    local failed_job_id
    failed_job_id="$(
    print -r -- "$json" \
      | _ci_status_parse \
      | jq -r '.jobs[] | select(.job_status=="failed") | .job_id' \
      | head -n 1
    )"

    if [[ -n "$failed_job_id" ]]; then
        print -n -- "$failed_job_id" | pbcopy
        print -P -- "\n%F{yellow}Copied failed job id to clipboard:%f %F{magenta}$failed_job_id%f"
    fi
}


ci-status() {
    local branch
    branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)" || return 1
    _ci_status_for_branch "$branch"
}

ci-status-for() {
    local branch
    branch="$(
    git for-each-ref --format='%(refname:short)' refs/heads refs/remotes \
      | sed 's#^origin/##' \
      | grep -v '^origin/HEAD$' \
      | sort -u \
      | fzf --prompt='Branch > ' --height=40% --layout=reverse --border
    )" || return 1
    _ci_status_for_branch "$branch"
}

ci-trace() {
    local job_id="$1"
    [[ -n "$job_id" ]] || { print -r -- "usage: ci_trace <job_id>"; return 1; }

    glab ci trace "$job_id" \
    | awk -v gray="\033[90m" -v reset="\033[0m" '
  {
    line = $0
    while (match(line, /section_(start|end):[0-9]+:[^[:space:]]+/)) {
      pre = substr(line, 1, RSTART - 1)
      token = substr(line, RSTART, RLENGTH)
      post = substr(line, RSTART + RLENGTH)
      if (pre != "") print pre
        split(token, a, ":")
        type = a[1]; name = a[3]
        if (type == "section_start") print gray "==> START " name reset
        else print gray "<== END " name reset
          line = post
        }
      if (line != "") print line
      }
    ' | bat --pager="less -FR +G"
}

dsf() {
    diff -u "$@" | diff-so-fancy
}

gl() {
    if [[ $# -eq 0 ]]; then
        git log --color=always --pretty=format:'%s%n%C(red)%h%C(reset) %C(auto)%d%C(reset)%n' -10
    else
        git log --color=always --pretty=format:'%s%n%C(red)%h%C(reset) %C(auto)%d%C(reset)%n' "$@"
    fi
}

view-commit() {
    local sha="$1"
    if [[ -z "$sha" ]]; then
        echo "usage: view_commit <sha>"
        return 1
    fi
    local url="https://git.insea.io/harbor.insea.io/seaweb/infracenter-be/-/commits/${sha}"
    printf "%s" "$url" | pbcopy
    open "$url"
}

view-jira() {
    local id="$1"
    if [[ -z "$id" && ! -t 0 ]]; then
        id="$(cat)"
        id="${id#"${id%%[![:space:]]*}"}"
        id="${id%"${id##*[![:space:]]}"}"
    fi
    if [[ -z "$id" ]]; then
        echo "usage: view-jira <ticket id> (or pipe via stdin)"
        return 1
    fi
    id="${id#MIS-}"
    local url="https://jira.garenanow.com/browse/MIS-${id}"
    printf "%s" "$url" | pbcopy
    open "$url"
}

alias cd-downloads='cd ~/Downloads'

test() {
    local filename="$1"
    shift
    local keywords="$*"
    poetry run pytest ${filename} -k ${keywords} -vv --show-capture=all
}

jira-auth() {
    if [[ -z "${JIRA_API_TOKEN:-}" ]]; then
        local token
        token="$(security find-generic-password -a "$USER" -s JIRA_API_TOKEN -w)" || return 1
        export JIRA_API_TOKEN="$token"
    fi
    export JIRA_AUTH_TYPE=bearer
}

## fzf search Jira issues (key/summary/description/type/assignee/fixVersions) with preview
## Requires: jq, fzf, glow
## Usage:
##   jira-fzf [-o] [-A] "<JQL>"                # uses default prompt
##   jira-fzf [-o] [-A] "<JQL>" "prompt> "      # optional prompt
##   jira-fzf [-o] [-A] "<JQL>" "prompt> " "initial search"
jira-fzf() {
    local open_after=0
    local fetch_all=0
    while [[ "$1" == -* ]]; do
        case "$1" in
            -o) open_after=1 ;;
            -A) fetch_all=1 ;;
            *) break ;;
        esac
        shift
    done
    local jql="$1"
    local prompt="${2:-jira> }"
    local initial="${3:-}"
    if [[ -z "$jql" ]]; then
        echo "usage: jira-fzf [-o] [-A] <jql> [prompt] [initial query]"
        return 1
    fi

    jira-auth || return 1
    setopt local_options local_traps

    # Temp file to hold a sanitized JSON page
    local tmp_page
    tmp_page="$(mktemp -t jira_issues_page.XXXXXX)" || return 1
    trap 'rm -f "$tmp_page"' INT TERM EXIT

    # Stream pages so fzf can show results after the first page.
    local offset=0 count=0
    local selected_key
    selected_key="$(
    {
        while :; do
            if ! jira issue list --raw -q "$jql" --paginate "${offset}:100" --order-by updated 2>/dev/null \
                | perl -pe 's/[\x00-\x08\x0B\x0C\x0E-\x1F]//g' \
                > "$tmp_page"; then
                echo "Failed to fetch issues (check auth/JQL)." >&2
                break
            fi

            if ! jq -e 'type=="array"' "$tmp_page" >/dev/null 2>&1; then
                echo "Unexpected output (not a JSON array)." >&2
                break
            fi

            jq -r '
      def semver_key:
        capture("^(?:v)?(?<maj>[0-9]+)\\.(?<min>[0-9]+)\\.(?<pat>[0-9]+)$")
        | [(.maj|tonumber), (.min|tonumber), (.pat|tonumber)];

      (map(.fields.fixVersions[]?.name? // empty)
        | map(gsub("(?i)^infra ?center ?-? ?"; "") | ascii_downcase)
        | map(select(test("^v?[0-9]+\\.[0-9]+\\.[0-9]+$")))
        | map({s: ., v: (semver_key)})
        | sort_by(.v)
        | (last | .s // "")
      ) as $latest_semver
      | .[] as $item
      | [
          $item.key,
          ($item.key as $k
            | if ($k | test("^[A-Z]+-[0-9]+$")) then
                ($k
                  | capture("^(?<prefix>[^-]+-)(?<num>.+)$") as $cap
                  | (($item.fields.assignee.displayName // "")
                      | test("(?i)^cai")
                    ) as $is_cai
                  | (if $is_cai then "\u001b[31m" else "\u001b[38;5;214m" end) as $num_color
                  | "\($cap.prefix)\($num_color)\($cap.num)\u001b[0m")
              else
                $k
              end) as $k_color
          | (($item.fields.summary // "") | gsub("(?i)^infra ?center ?-? ?"; "")) as $summary
          | (if ($summary | test("^\\[[^]]+\\]")) then
                ($summary
                  | capture("^(?<tag>\\[[^]]+\\])(?<rest>.*)$")
                  | "\u001b[35m\u001b[4m\(.tag)\u001b[24m\(.rest)\u001b[0m")
              else
                "\u001b[35m\($summary)\u001b[0m"
              end) as $summary_purple
          | ($item.fields.status.name // "") as $status_raw
          | (if ($status_raw | test("(?i)^waiting$")) then "WAIT"
              elif ($status_raw | test("(?i)^doing$")) then "DOIN"
              elif ($status_raw | test("(?i)^testing$")) then "TEST"
              elif ($status_raw | test("(?i)^done$")) then "DONE"
              elif ($status_raw | test("(?i)^closed$")) then "CLSE"
              elif ($status_raw | test("(?i)^delivering$")) then "DLVR"
              else $status_raw
            end) as $status_label
          | (if ($status_raw | test("(?i)^(waiting|doing)$")) then "\u001b[34m"
              elif ($status_raw | test("(?i)^(testing|delivering)$")) then "\u001b[32m"
              elif ($status_raw | test("(?i)^(done|closed)$")) then "\u001b[90m"
              else ""
            end) as $status_color
          | ($status_color + $status_label + "\u001b[0m") as $status_fmt
          | (($item.fields.issueType.name // "") | ascii_downcase) as $type_raw
          | (if $type_raw == "bug" then "B:"
              elif $type_raw == "task" then "T:"
              else (($item.fields.issueType.name // "") + ":")
            end) as $type_label
          | ("\u001b[90m" + $type_label + "\u001b[0m") as $type_fmt
          | ($item.fields.assignee.displayName? // "") as $assignee_name
          | (if ($assignee_name | type) == "string" then $assignee_name else "" end) as $assignee_str
          | ((if $assignee_str == "" then "" else ($assignee_str | split(" "))[0] end) | ascii_downcase) as $assignee_first
          | (if $assignee_str == "" then "unassigned"
              else ("@" + $assignee_first)
            end) as $assignee_tag
          | (if ($assignee_tag | length) > 5 then ($assignee_tag[0:5]) else ($assignee_tag + (" " * (5 - ($assignee_tag | length)))) end) as $assignee_fixed
          | (if $assignee_first == "cai" then "\u001b[31m" + $assignee_tag + "\u001b[0m"
              else $assignee_tag
            end) as $assignee_colored
          | (if $assignee_str == "" then "\u001b[90m\u001b[4m" + $assignee_fixed + "\u001b[24m\u001b[0m"
              elif $assignee_first == "cai" then "\u001b[31m" + $assignee_fixed + "\u001b[0m"
              else "\u001b[33m" + $assignee_fixed + "\u001b[0m"
            end) as $assignee_fmt
          | (($item.fields.fixVersions // []) | map(.name | gsub("(?i)^infra ?center ?-? ?"; "") | ascii_downcase)) as $fix_list
          | ($fix_list | join("; ")) as $fix_raw_base
          | (if $fix_raw_base == "backlog" then "bklog"
              elif $fix_raw_base == "be tech debts" then "bedebt"
              elif $fix_raw_base == "qa tech debts" then "qadebt"
              else $fix_raw_base
            end) as $fix_base_norm
          | (if $fix_base_norm != "" and $fix_base_norm != "bklog" and $fix_base_norm != "bedebt" and $fix_base_norm != "qadebt" then ("v" + $fix_base_norm) else $fix_base_norm end) as $fix_raw
          | (if ($fix_raw | length) > 6 then ($fix_raw[0:6]) else ($fix_raw + (" " * (6 - ($fix_raw | length)))) end) as $fix_fmt
          | (if $fix_base_norm == "bklog" or $fix_base_norm == "bedebt" or $fix_base_norm == "qadebt" then "\u001b[90m" + $fix_fmt + "\u001b[0m"
              elif $latest_semver != "" and $fix_raw_base == $latest_semver then "\u001b[34m" + $fix_fmt + "\u001b[0m"
              else $fix_fmt
            end) as $fix_fmt
          | (($item.fields.priority.name // "") | ascii_downcase) as $priority_raw
          | (if $priority_raw == "highest" then "P0"
              elif $priority_raw == "high" then "P1"
              elif $priority_raw == "medium" then "P2"
              elif $priority_raw == "low" then "P3"
              elif $priority_raw == "lowest" then "P4"
              else "P?"
            end) as $priority_label
          | (if $priority_label == "P0" then "\u001b[31m\u001b[1m\u001b[3m\u001b[4mP0\u001b[24m\u001b[23m\u001b[22m\u001b[0m"
              elif $priority_label == "P1" then "\u001b[31mP1\u001b[0m"
              elif $priority_label == "P2" then "\u001b[38;5;208mP2\u001b[0m"
              elif $priority_label == "P3" then "\u001b[34mP3\u001b[0m"
              elif $priority_label == "P4" then "\u001b[94mP4\u001b[0m"
              else "\u001b[90m" + $priority_label + "\u001b[0m"
            end) as $priority_fmt
          | ($item.fields.updated // "") as $updated_raw
          | (if $updated_raw == "" then ""
              else
                ($updated_raw
                  | sub("\\.[0-9]+"; "")
                  | strptime("%Y-%m-%dT%H:%M:%S%z")
                  | mktime) as $updated_ts
                | (now | floor) as $now_ts
                | ($now_ts - $updated_ts) as $age
                | (if $age < 60 then "just now"
                    elif $age < 3600 then
                      ((($age/60)|floor) as $mins
                       | (if $mins == 1 then "1 min ago" else "\($mins) mins ago" end))
                    elif $age < 86400 then
                      ((($age/3600)|floor) as $hrs
                       | (if $hrs == 1 then "1 hr ago" else "\($hrs) hrs ago" end))
                    else
                      (($age/86400)|floor) as $days
                      | ((($age % 86400)/3600)|floor) as $hrs
                      | (if $hrs == 0 then
                            (if $days == 1 then "1 day ago" else "\($days) days ago" end)
                          else
                            (if $days == 1 then "1 day \($hrs) hrs ago" else "\($days) days \($hrs) hrs ago" end)
                        end)
                  end)
              end) as $updated_short
          | ("\u001b[90m(" + $updated_short + ")\u001b[0m") as $updated_fmt
          | ($priority_fmt
              + " " + $type_fmt
              + " " + $k_color
              + "  " + $status_fmt
              + "  " + $assignee_fmt
              + "  " + $fix_fmt
              + "  " + $summary_purple
              + "  " + $updated_fmt
            )
        ]
      | @tsv
    ' "$tmp_page" || break

            count="$(jq 'length' "$tmp_page")"
            if (( count < 100 )); then
                break
            fi
            if (( fetch_all == 0 )); then
                break
            fi
            offset=$((offset + 100))
            if (( offset >= 1000 )); then
                break
            fi
        done
    } \
    | fzf --height 90% --reverse --cycle --ansi \
          --prompt="$prompt" \
          ${initial:+--query="$initial"} \
          --delimiter=$'\t' --with-nth=2 \
          --preview-window=right:100:wrap \
          --preview "
    k=\$(printf '%s' {} | cut -f1)
    jira issue view --plain \"\$k\" | sed 's/\\x1B\\[[0-9;]*[A-Za-z]//g' | CLICOLOR_FORCE=1 glow -p -w 100 -s dracula
    "     | cut -f1
  )"

    if [[ -n "$selected_key" ]]; then
        jira issue view "$selected_key" --plain | sed 's/\x1B\[[0-9;]*[A-Za-z]//g' | glow -s dark -w 0
        printf '%s' "$selected_key" | pbcopy
        if (( open_after )); then
            view-jira "$selected_key"
        fi
    fi
}

jira-jql() {
    local extra="${1:-}"
    if [[ -n "$extra" ]]; then
        printf "%s AND (%s)" "fixVersion ~ 'infracenter*'" "$extra"
    else
        printf "%s" "fixVersion ~ 'infracenter*'"
    fi
}

jira-mine() {
    local -a flags=()
    while [[ "$1" == -* ]]; do
        case "$1" in
            -o|-A) flags+=("$1") ;;
            *) break ;;
        esac
        shift
    done
    jira-fzf "${flags[@]}" "$(jira-jql "assignee = currentUser()")" "mine> " "${1:-}"
}

jira-pend() {
    local -a flags=()
    while [[ "$1" == -* ]]; do
        case "$1" in
            -o|-A) flags+=("$1") ;;
            *) break ;;
        esac
        shift
    done
    jira-fzf "${flags[@]}" "$(jira-jql "status in (Doing, Waiting)")" "pending> " "${1:-!qadebt !bedebt !bklog }"
}

jira-my-pend() {
    local -a flags=()
    while [[ "$1" == -* ]]; do
        case "$1" in
            -o|-A) flags+=("$1") ;;
            *) break ;;
        esac
        shift
    done
    jira-fzf "${flags[@]}" "$(jira-jql "assignee = currentUser() AND status in (Doing, Waiting)")" "my pending> " "${1:-!qadebt !bedebt !bklog }"
}

# jira-v 1.8.1
# jira-v backlog
# jira-v "be tech debts"
# jira-v "qa tech debts"
jira-v() {
    local -a flags=()
    while [[ "$1" == -* ]]; do
        case "$1" in
            -o|-A) flags+=("$1") ;;
            *) break ;;
        esac
        shift
    done
    local ver="$1"
    if [[ -z "$ver" ]]; then
        echo "usage: jzf-v [-o] [-A] <version>"
        return 1
    fi
    jira-fzf "${flags[@]}" "$(jira-jql "fixVersion ~ '*${ver}'")" "${ver}> " ""
}

jira-all() {
    local -a flags=()
    while [[ "$1" == -* ]]; do
        case "$1" in
            -o|-A) flags+=("$1") ;;
            *) break ;;
        esac
        shift
    done
    jira-fzf "${flags[@]}" "$(jira-jql "")" "all> " "${1:-}"
}

jira-mv-testing() {
    local ticket_id=""

    if [ -n "$1" ]; then
        ticket_id="$1"
    elif [ ! -t 0 ]; then
        IFS= read -r ticket_id
    fi

    if [ -z "$ticket_id" ]; then
        echo "usage: jira-mv-testing <ticket id>" >&2
        return 2
    fi

    jira issue move "$ticket_id" Testing
}

jira-mv-doing() {
    local ticket_id=""

    if [ -n "$1" ]; then
        ticket_id="$1"
    elif [ ! -t 0 ]; then
        IFS= read -r ticket_id
    fi

    if [ -z "$ticket_id" ]; then
        echo "usage: jira-mv-testing <ticket id>" >&2
        return 2
    fi

    jira issue move "$ticket_id" Doing
}

# docker fzf
FZF_DOCKER_PS_FORMAT="table {{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Ports}}"
FZF_DOCKER_PS_START_FORMAT="table {{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Image}}"

_fzf_complete_docker() {
    # Get all Docker commands
    #
    # Cut below "Management Commands:", then exclude "Management Commands:",
    # "Commands:" and the last line of the help. Then keep the first column and
    # delete empty lines
    DOCKER_COMMANDS=$(docker --help 2>&1 >/dev/null |
        sed -n -e '/Management Commands:/,$p' |
        grep -v "Management Commands:" |
        grep -v "Commands:" |
        grep -v 'COMMAND --help' |
        grep .
    )

    ARGS="$@"
    if [[ $ARGS == 'docker ' ]]; then
        _fzf_complete "--reverse -n 1 --height=80%" "$@" < <(
            echo $DOCKER_COMMANDS
        )
    elif [[ $ARGS == 'docker tag'* || $ARGS == 'docker -f'* || $ARGS == 'docker run'* || $ARGS == 'docker push'* ]]; then
        _fzf_complete "--multi --header-lines=1" "$@" < <(
            docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.ID}}\t{{.CreatedSince}}"
        )
    elif [[ $ARGS == 'docker rmi'* ]]; then
        _fzf_complete "--multi --header-lines=1" "$@" < <(
            docker images --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}\t{{.Size}}"
        )
    elif [[ $ARGS == 'docker stop'* || $ARGS == 'docker exec'* || $ARGS == 'docker kill'* || $ARGS == 'docker restart'* ]]; then
        _fzf_complete "--multi --header-lines=1 " "$@" < <(
            docker ps --format "${FZF_DOCKER_PS_FORMAT}"
        )
    elif [[ $ARGS == 'docker logs'* ]]; then
        _fzf_complete "--multi --header-lines=1 --header 'Enter CTRL-O to open log in editor | CTRL-/ to change height\n\n' --bind 'ctrl-/:change-preview-window(80%,border-bottom|)' --bind \"ctrl-o:execute:docker logs {1} | sed 's/\x1b\[[0-9;]*m//g' | cat | ${EDITOR:-vim} -\" --preview-window up:follow --preview 'docker logs --follow --tail=100 {1}' " "$@" < <(
            docker ps -a --format "${FZF_DOCKER_PS_FORMAT}"
        )
    elif [[ $ARGS == 'docker rm'* ]]; then
        _fzf_complete "--multi --header-lines=1 " "$@" < <(
            docker ps -a --format "${FZF_DOCKER_PS_FORMAT}"
        )
    elif [[ $ARGS == 'docker start'* ]]; then
        _fzf_complete "--multi --header-lines=1 " "$@" < <(
            docker ps -a --format "${FZF_DOCKER_PS_START_FORMAT}"
        )
    fi
}

_fzf_complete_docker_post() {
    # Post-process the fzf output to keep only the command name and not the explanation with it
    awk '{print $1}'
}

[ -n "$BASH" ] && complete -F _fzf_complete_docker -o default -o bashdefault docker

# yazi
function y() {
    local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
    command yazi "$@" --cwd-file="$tmp"
    IFS= read -r -d '' cwd < "$tmp"
    [ -n "$cwd" ] && [ "$cwd" != "$PWD" ] && builtin cd -- "$cwd"
    rm -f -- "$tmp"
}

# motd
(printf '\n%.0s' {1..2}; if [ $((RANDOM % 10)) -eq 0 ]; then pokemon-colorscripts -r 1-3 -s --no-title; else pokemon-colorscripts -r 1-3 --no-title; fi) | sed 's/^/        /'
fortune -s | sed 's/^/  /'
