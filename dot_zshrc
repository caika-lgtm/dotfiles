export ZSH="$HOME/.oh-my-zsh"
export FZF_BASE=/usr/local/bin/fzf
ZSH_THEME=""
COMPLETION_WAITING_DOTS="true"
zvm_config() {
    ZVM_INSERT_MODE_CURSOR=$ZVM_CURSOR_BLINKING_UNDERLINE
}
plugins=(
    git
    branch
    colored-man-pages
    colorize
    zsh-syntax-highlighting
    zsh-autosuggestions
    zsh-vi-mode
    # fzf
    fzf-zsh-plugin
)
source $ZSH/oh-my-zsh.sh

export PATH=$HOME/go/bin:$PATH
export PATH="$PATH:/Users/SG3937/.local/bin"

unalias gg 2>/dev/null
unalias gl 2>/dev/null
unalias gr 2>/dev/null
unalias grs 2>/dev/null
unalias l 2>/dev/null

# alias l="ls -la"
eza_base() {
    setopt local_options GLOB_DOTS NULL_GLOB
    eza --icons=auto --group-directories-first --smart-group --git "$@"
}

l()    { eza_base -la "$@"; }
lt()   { eza_base -la -T -L 2 "$@"; }
ltt()  { eza_base -la -T -L 3 "$@"; }

lh()   { eza_base -lb "$@"; }
lht()  { eza_base -lb -T -L 2 "$@"; }
lhtt() { eza_base -lb -T -L 3 "$@"; }

lH()   { eza_base -lb --git-ignore "$@"; }
lHt()  { eza_base -lb -T -L 2 --git-ignore "$@"; }
lHtt() { eza_base -lb -T -L 3 --git-ignore "$@"; }

li()   { eza_base -la --git-ignore "$@"; }
lit()  { eza_base -la -T -L 2 --git-ignore "$@"; }
litt() { eza_base -la -T -L 3 --git-ignore "$@"; }

alias gr="git restore ."
alias grs="git restore --staged ."


export EDITOR='nvim'
# alias nap="EDITOR=nvim nap"
alias checkout='fzf-git-checkout && g pull'
# emodipt-extend, kali, stelbent.minimal
eval "$(oh-my-posh init zsh --config ~/.mytheme.omp.json)"

zvm_after_init_commands+=('[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh')

export FZF_PREVIEW_ADVANCED=1
export FZF_PREVIEW_COMMAND="bat --style=numbers,changes --wrap never --color always {} || cat {} || tree -C {}"
export FZF_COMMON_OPTIONS="
  --bind='?:toggle-preview'
  --bind='ctrl-u:preview-page-up'
  --bind='ctrl-d:preview-page-down'
  --preview '([[ -d {} ]] && tree -C {}) || ([[ -f {} ]] && bat --style=full --color=always {}) || echo {}'
  --color=fg:-1,fg+:#d0d0d0,bg:-1,bg+:#262626
  --color=hl:#5f87af,hl+:#5fd7ff,info:#afaf87,marker:#87ff00
  --color=prompt:#d7005f,spinner:#af5fff,pointer:#af5fff,header:#87afaf
  --color=border:#262626,label:#aeaeae,query:#d9d9d9
  --border='thinblock' --border-label='' --preview-window='border-rounded' --padding=0
  --prompt='> ' --marker='>' --pointer='â—†' --separator='â”€'
  --scrollbar='â”‚' --layout='reverse' --info='right'"

command -v fd > /dev/null && export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git'
command -v bat > /dev/null && command -v tree > /dev/null && export FZF_DEFAULT_OPTS="$FZF_COMMON_OPTIONS"
command -v fd > /dev/null && export FZF_ALT_C_COMMAND='fd --type d --hidden --follow --exclude .git'
command -v fd > /dev/null && export FZF_CTRL_T_COMMAND='fd --type f --type d --hidden --follow --exclude .git'

source <(fzf --zsh)

rundev() {
    local container_name="infra-center-dev-container"
    local workdir = "/var/www/infra-center"
    docker exec -it "$container_name" sh -c "cd $workdir && $*"
}

enterdev() {
    local container_name="infra-center-dev-container"
    local workdir="/var/www/infra-center"
    echo "cd $workdir" | pbcopy
    docker exec -it "$container_name" bash
}

devc() {
    local type="$1"  # 'feat', 'fix', for e.g.
    local message="$2"
    local branch_name=$(git rev-parse --abbrev-ref HEAD)
    local ticket_id=$(echo "$branch_name" | grep -oE '[A-Z]+-[0-9]+')

    if [[ -z "$ticket_id" ]]; then
        echo "ğŸ˜¢ No ticket ID found in branch name. Aborting commit."
        return 1
    fi

    local formatted_message="$type: [$ticket_id] $message"
    echo "ğŸ‰ Committing with message: \"$formatted_message\""
    # rundev git commit --verbose -m "'$formatted_message'"
    git commit --verbose -m "$formatted_message"
}

cfeat() {
    devc "feat" "$1"
}

cfix() {
    devc "fix" "$1"
}

cchore() {
    devc "chore" "$1"
}

crefactor() {
    devc "refactor" "$1"
}

# alias gca='rundev git commit --verbose --all --date=now --no-edit --amend'
alias gca='git commit --verbose --all --date=now --no-edit --amend'
alias pre="rundev 'poetry run mycli -h infra_center_db -P 3306 -u root -proot -e \"drop database infra_center_db; create database infra_center_db\" && poetry run alembic upgrade head'"

export LESSOPEN="|/opt/homebrew/bin/lesspipe.sh %s"
alias editzshrc='chezmoi edit ~/.zshrc && chezmoi apply'
alias vim='nvim'

export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init --path)"
eval "$(pyenv init -)"

export NAP_CONFIG="~/.nap/config.yaml"
export NAP_HOME="~/.nap"


mr-create() {
    local target_branch mr_output mr_url

    target_branch=$(
        git branch --format='%(refname:short)' \
            | fzf --prompt="Target branch > "  --height=40% --layout=reverse --border
    )
    if [[ -z "$target_branch" ]]; then
        echo "No target branch selected."
        return 1
    fi

    mr_output=$(glab mr create -a @me -f -l "ReadyForReview ğŸ‘€" -b "$target_branch")
    echo "$mr_output"

    mr_url=$(echo "$mr_output" | rg -o 'https?://[^ ]+/merge_requests/[0-9]+' | tail -n 1)
    if [[ -n "$mr_url" ]]; then
        echo -n "$mr_url" | pbcopy
        echo "MR URL copied to clipboard."
    else
        echo "MR URL not found in output."
        return 1
    fi
}


mr-view() {
    glab mr view "${1:-$(g branch --show-current)}" -w
}

mr-rebase() {
    local branch
    branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)" || return 1
    if [[ -z "$branch" || "$branch" == "HEAD" ]]; then
        echo "mr_rebase: not on a branch" >&2
        return 1
    fi
    glab mr rebase "$branch"
}

mr-target() {
    local current_branch target_branch
    current_branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)" || return 1
    if [[ -z "$current_branch" || "$current_branch" == "HEAD" ]]; then
        echo "mr_target: not on a branch" >&2
        return 1
    fi

    target_branch="$(
    git for-each-ref --format='%(refname:short)' refs/heads/ \
      | fzf --prompt="Target branch > " --height=40% --layout=reverse --border
  )" || return 1

    if [[ -z "$target_branch" ]]; then
        echo "mr_target: no target branch selected" >&2
        return 1
    fi

    glab mr update "$current_branch" --target-branch "$target_branch"
}

ci-status-short() {
    local branch="$1"
    if [[ -z "$branch" ]]; then
        echo "usage: ci-status-short <branch>"
        return 1
    fi

    local output pipe_status stages red reset
    red=$'\e[31m'
    reset=$'\e[0m'

    output="$(glab ci get -b "$branch" -d 2>/dev/null)" || {
        echo "ğŸ”"
        return 1
    }

    pipe_status="$(printf "%s\n" "$output" | awk -F: '/^status:/ {gsub(/^[ \t]+/, "", $2); print $2; exit}')"

    if [[ "$pipe_status" == "failed" ]]; then
        stages=("${(@f)$(printf "%s\n" "$output" \
        | awk '
            BEGIN {in_jobs=0}
            /^# Jobs:/ {in_jobs=1; next}
            in_jobs && /^ID[[:space:]]+Name/ {next}
            in_jobs {
              for (i=1; i<=NF; i++) {
                if ($i ~ /^(failed|success|skipped|running|pending)$/) {
                  status_text=$i
                  name=""
                  for (j=2; j<i; j++) {
                    name = name (j==2 ? "" : " ") $j
                  }
                  if (status_text=="failed") {
                    sub(/:.*/, "", name)
                    print name
                  }
                  break
                }
              }
            }' \
        | awk '!seen[$0]++'
      )}")

        if (( ${#stages[@]} > 0 )); then
            echo "${red}ğŸ‘ (${(j:, :)stages})${reset}"
        else
            echo "${red}ğŸ‘${reset}"
        fi
    elif [[ "$pipe_status" == "success" ]]; then
        echo "ğŸ‰"
    elif [[ "$pipe_status" == "pending" ]]; then
        echo "ğŸ™"
    elif [[ "$pipe_status" == "running" ]]; then
        echo "ğŸƒ"
    elif [[ "$pipe_status" == "canceled" ]]; then
        echo "ğŸš«"
    elif [[ "$pipe_status" == "skipped" ]]; then
        echo "â­ï¸"
    elif [[ "$pipe_status" == "created" ]]; then
        echo "ğŸš§"
    elif [[ "$pipe_status" == "manual" ]]; then
        echo "ğŸ“"
    elif [[ "$pipe_status" == "waiting_for_resource" ]]; then
        echo "ğŸ’¤"
    elif [[ "$pipe_status" == "preparing" ]]; then
        echo "â³"
    elif [[ "$pipe_status" == "scheduled" ]]; then
        echo "ğŸ“…"
    else
        echo "â“"
    fi
}

mrs() {
    local jq_filter
    jq_filter='
      .[] | [
        (.iid|tostring),
        .source_branch,
        .target_branch,
        ((.labels | map(select(test("release|improvement|review"; "i"))) | if length==0 then "-" else join(", ") end)),
        .detailed_merge_status,
        .state,
        (.updated_at as $t
          | ($t | sub("\\.[0-9]+";"")) as $t
          | ($t[0:-3] + $t[-2:])
          | strptime("%Y-%m-%dT%H:%M:%S%z")
          | mktime
          | strftime("%d %b %I:%M%p")
          | sub("^0";"")
          | sub(" 0";" ")
        )
      ] | @tsv
    '
    local awk_fmt
    awk_fmt='
      function strip_ansi(s, t) {
        t = s
        gsub(/\033\[[0-9;]*m/, "", t)
        return t
      }
      function vislen(s) {
        return length(strip_ansi(s))
      }
      function pad(s, w) {
        padlen = w - vislen(s)
        if (padlen < 0) padlen = 0
        padstr = sprintf("%*s", padlen, "")
        gsub(/ /, ".", padstr)
        return s GRAY padstr RESET
      }
      function ruler(n, ch) {
        s = sprintf("%*s", n, "")
        gsub(/ /, ch, s)
        return s
      }
      {
        split($0, f, "\t")
        iid="!" f[1]
        src=f[2]
        tgt=f[3]
        label=f[4]
        status=f[5]
        state=f[6]
        pipe=f[7]
        updated=f[8]
        status_state = state " (" status ")"

        r1[NR]=iid; r2[NR]=src; r3[NR]=tgt; r4[NR]=label; r5[NR]=status_state; r6[NR]=pipe; r7[NR]=updated
        s5[NR]=status; s6[NR]=state; lab[NR]=label

        if (vislen(r1[NR])>w[1]) w[1]=vislen(r1[NR])
        if (vislen(r2[NR])>w[2]) w[2]=vislen(r2[NR])
        if (vislen(r3[NR])>w[3]) w[3]=vislen(r3[NR])
        if (vislen(r4[NR])>w[4]) w[4]=vislen(r4[NR])
        if (vislen(r5[NR])>w[5]) w[5]=vislen(r5[NR])
        if (vislen(r6[NR])>w[6]) w[6]=vislen(r6[NR])
        if (vislen(r7[NR])>w[7]) w[7]=vislen(r7[NR])
      }
      END {
        ORANGE="\033[38;5;208m"
        GREEN="\033[0;32m"
        WHITE="\033[0;37m"
        PURPLE="\033[0;35m"
        GRAY="\033[0;90m"
        RESET="\033[0m"

        sep_done=0
        for (r=1;r<=NR;r++) {
          label_color = (lab[r] ~ /WaitingForImprovement/) ? "\033[0;31m" : "\033[0;32m"

          status=s5[r]
          state=s6[r]
          if (status ~ /^(mergeable|ci_must_pass)$/) status_color=GREEN
          else if (status ~ /^(conflicts|ci_failed|approval_needed|not_approved|draft_status|blocked_status|policies_denied|external_status_checks|broken_status)$/) status_color=ORANGE
          else status_color=WHITE
          if (state == "merged") status_color=GRAY

          if (state == "merged" && !sep_done) {
            width = w[1]+1 + w[2] + w[3] + w[4] + w[5] + w[6] + w[7] + 6
            printf "%s%s%s\n", GRAY, ruler(width, "-"), RESET
            sep_done=1
          }

          printf "\033[0;37m%s\033[0m \033[0;33m%s\033[0m %s%s\033[0m %s%s\033[0m %s%s\033[0m %s%s\033[0m %s%s\033[0m\n",
            pad(r1[r], w[1]+1),
            pad(r2[r], w[2]),
            PURPLE, pad(r3[r], w[3]),
            label_color, pad(r4[r], w[4]),
            status_color, pad(r5[r], w[5]),
            WHITE, pad(r6[r], w[6]),
            WHITE, pad(r7[r], w[7])
        }
      }
      '

    local -a args=()
    local all=0
    for arg in "$@"; do
        if [[ $arg == -A ]]; then
            all=1
        else
            args+=("$arg")
        fi
    done

    if (( all )); then
        jq -s '.[0] + .[1]' \
            <(glab mr list --author @me -F json -o updated_at -S desc "${args[@]}") \
            <(glab mr list --author @me -F json -o updated_at -S desc -M -P 10 "${args[@]}") \
            | jq -r "$jq_filter" \
            | {
            while IFS=$'\t' read -r iid src tgt label merge_status state updated; do
                pipe=$(ci-status-short "$src")
                printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' \
                    "$iid" "$src" "$tgt" "$label" "$merge_status" "$state" "$pipe" "$updated"
            done
        } | awk -F $'\t' "$awk_fmt"
    else
        glab mr list --author @me -F json -o updated_at -S desc "${args[@]}" \
            | jq -r "$jq_filter" \
            | {
            while IFS=$'\t' read -r iid src tgt label merge_status state updated; do
                pipe=$(ci-status-short "$src")
                printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' \
                    "$iid" "$src" "$tgt" "$label" "$merge_status" "$state" "$pipe" "$updated"
            done
        } | awk -F $'\t' "$awk_fmt"
    fi
}

_ci_status_parse() {
    jq -r '
  def dur(s):
  if s == null then ""
  else
    (s | floor) as $t
    | ($t / 3600 | floor) as $h
    | ($t % 3600 / 60 | floor) as $m
    | ($t % 60) as $sec
    | if $h > 0 then
    "\($h)h" + (if $m < 10 then "0" else "" end) + "\($m)m" + (if $sec < 10 then "0" else "" end) + "\($sec)s"
  else
    "\($m)m\($sec)s"
  end
end;

{
  pipeline_id: .id,
  pipeline_status: .status,
  user_username: .user.username,
  finished_at: .finished_at,
  jobs: (.jobs // [] | map({
    commit_short_id: .commit.short_id,
    job_name: .name,
    job_id: .id,
    job_status: .status,
    job_duration: dur(.duration),
    job_failure_reason: .failure_reason
  }))
}'
}

_ci_status_format_line() {
    jq -r '
  def status_emoji(s):
  if s == "failed" then "ğŸ˜"
  elif s == "success" then "ğŸ‰"
  else "â³"
  end;

  def normalize_ts:
  .
  | sub("\\.[0-9]+"; "")
  | if test("([+-][0-9]{2}):([0-9]{2})$") then
  (capture("^(?<base>.*)(?<tz>[+-][0-9]{2}):(?<tzm>[0-9]{2})$") | "\(.base)\(.tz)\(.tzm)")
else
  .
end;

def finished_label(x):
if x == null then ""
else
  (" finished at " + (
    x
    | normalize_ts
    | strptime("%Y-%m-%dT%H:%M:%S%z")
    | mktime
    | strftime("%d %b %I:%M%p")
    | sub("^0";"")
    | sub(" 0";" ")
    | ascii_upcase
    ))
  end;

  def commit_short:
  if (.jobs | length) > 0 then .jobs[0].commit_short_id else null end;

    "Pipeline \(.pipeline_id) \(.pipeline_status) \(status_emoji(.pipeline_status)) triggered by @\(.user_username) for \(commit_short)\(finished_label(.finished_at))."
    '
}

_ci_status_colorize() {
    local line
    while IFS= read -r line; do
        if [[ $line =~ '^Pipeline ([0-9]+) ([^ ]+) ([^ ]+) triggered by @([^ ]+) for ([^ ]+)( finished at (.+))?\.$' ]]; then
            local id="${match[1]}"
            local status_text="${match[2]}"
            local emoji="${match[3]}"
            local user="${match[4]}"
            local sha="${match[5]}"
            local finished="${match[7]}"

            local purple='%F{magenta}'
            local highlight='%F{yellow}'
            local reset='%f'

            local status_color
            case "$status_text" in
                success) status_color='%F{green}' ;;
                failed) status_color='%F{red}' ;;
                *) status_color='%F{yellow}' ;;
            esac

            local out="Pipeline ${purple}${id}${reset} ${status_color}${status_text}${reset} ${emoji} (triggered by @${highlight}${user}${reset} for ${highlight}${sha}${reset}"
            if [[ -n "$finished" ]]; then
                out+=" finished at ${highlight}${finished}${reset})"
            else
                out+=")"
            fi

            print -P -- "$out"
        else
            print -r -- "$line"
        fi
    done
}

_ci_status_jobs_table_pretty() {
    jq -r '
  def status_text(j):
  if j.job_status == "skipped" then "skipped"
  elif j.job_status == "success" then "success in \((j.job_duration // ""))"
  elif j.job_status == "failed" then
    "failed in \((j.job_duration // ""))" +
    (if (j.job_failure_reason // "") != "" then " (\(j.job_failure_reason))" else "" end)
  else
    j.job_status
  end;

  (.jobs[] | [(.job_id|tostring), .job_name, status_text(.)] | @tsv)
  ' | awk -F '\t' '
  {
    id[NR]=$1; name[NR]=$2; status[NR]=$3;
    if (length($1)>w1) w1=length($1);
      if (length($2)>w2) w2=length($2);
      }
  END{
    purple="\033[35m"; yellow="\033[33m"; red="\033[31m";
    green="\033[32m"; gray="\033[90m"; reset="\033[0m";
    for (i=1;i<=NR;i++){
      s=status[i];
      if (s ~ /^failed/) c=red;
      else if (s ~ /^success/) c=green;
      else if (s ~ /^skipped/) c=gray;
      else c=reset;
        printf "%s%-*s%s  %s%-*s%s  %s%s%s\n",
        purple, w1, id[i], reset,
        yellow, w2, name[i], reset,
        c, s, reset;
      }
  }
'
}

_ci_status_for_branch() {
    local branch="$1"
    [[ -n "$branch" ]] || return 1

    print -P -- "Showing CI status for branch %F{magenta}$branch%f"

    local json
    json="$(glab ci get -d -F json -b "$branch")" || return 1

    print -r -- "$json" | _ci_status_parse | _ci_status_format_line | _ci_status_colorize
    print -r -- "$json" | _ci_status_parse | _ci_status_jobs_table_pretty

    local failed_job_id
    failed_job_id="$(
    print -r -- "$json" \
      | _ci_status_parse \
      | jq -r '.jobs[] | select(.job_status=="failed") | .job_id' \
      | head -n 1
    )"

    if [[ -n "$failed_job_id" ]]; then
        print -n -- "$failed_job_id" | pbcopy
        print -P -- "\n%F{yellow}Copied failed job id to clipboard:%f %F{magenta}$failed_job_id%f"
    fi
}


ci-status() {
    local branch
    branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)" || return 1
    _ci_status_for_branch "$branch"
}

ci-status-for() {
    local branch
    branch="$(
    git for-each-ref --format='%(refname:short)' refs/heads refs/remotes \
      | sed 's#^origin/##' \
      | grep -v '^origin/HEAD$' \
      | sort -u \
      | fzf --prompt='Branch > ' --height=40% --layout=reverse --border
    )" || return 1
    _ci_status_for_branch "$branch"
}

ci-trace() {
    local job_id="$1"
    [[ -n "$job_id" ]] || { print -r -- "usage: ci_trace <job_id>"; return 1; }

    glab ci trace "$job_id" \
    | awk -v gray="\033[90m" -v reset="\033[0m" '
  {
    line = $0
    while (match(line, /section_(start|end):[0-9]+:[^[:space:]]+/)) {
      pre = substr(line, 1, RSTART - 1)
      token = substr(line, RSTART, RLENGTH)
      post = substr(line, RSTART + RLENGTH)
      if (pre != "") print pre
        split(token, a, ":")
        type = a[1]; name = a[3]
        if (type == "section_start") print gray "==> START " name reset
        else print gray "<== END " name reset
          line = post
        }
      if (line != "") print line
      }
    ' | bat --pager="less -FR +G"
}

dsf() {
    diff -u "$@" | diff-so-fancy
}

gl() {
    if [[ $# -eq 0 ]]; then
        git log --color=always --pretty=format:'%s%n%C(red)%h%C(reset) %C(auto)%d%C(reset)%n' -10
    else
        git log --color=always --pretty=format:'%s%n%C(red)%h%C(reset) %C(auto)%d%C(reset)%n' "$@"
    fi
}

view-commit() {
    local sha="$1"
    if [[ -z "$sha" ]]; then
        echo "usage: view_commit <sha>"
        return 1
    fi
    local url="https://git.insea.io/harbor.insea.io/seaweb/infracenter-be/-/commits/${sha}"
    printf "%s" "$url" | pbcopy
    open "$url"
}

view-jira() {
    local id="$1"
    if [[ -z "$id" ]]; then
        echo "usage: view-jira <ticket id>"
        return 1
    fi
    id="${id#MIS-}"
    local url="https://jira.garenanow.com/browse/MIS-${id}"
    printf "%s" "$url" | pbcopy
    open "$url"
}

alias cd-downloads='cd ~/Downloads'

test() {
    local filename="$1"
    shift
    local keywords="$*"
    rundev "poetry run pytest ${filename} -k ${keywords} -vv"
}

export JIRA_API_TOKEN="$(security find-generic-password -a "$USER" -s JIRA_API_TOKEN -w)"
export JIRA_AUTH_TYPE=bearer

# json="$(jira issue list --raw -q "fixVersion ~ 'infracenter*'" 2>/dev/null)" || {

# fzf search Jira issues (key/summary/description/type/assignee/fixVersions) with preview
# Requires: jq, fzf
# Usage:
#   jfz "initial search"         # optional initial query for fzf
#   jira issue view "$(jfz)"
#   open "https://jira.garenanow.com/browse/$(jfz)"
jfz() {
    local initial="${1:-}"

    # Temp file to hold sanitized JSON for fast previews
    local tmp
    tmp="$(mktemp -t jira_issues.XXXXXX)" || return 1
    trap 'rm -f "$tmp"' EXIT INT TERM

    # Fetch once, sanitize control chars (0x00-0x1F excluding \t \n \r), write to file
    jira issue list --raw -q "fixVersion ~ 'infracenter*'" 2>/dev/null \
        | perl -pe 's/[\x00-\x08\x0B\x0C\x0E-\x1F]//g' \
        > "$tmp" || { echo "Failed to fetch issues (check auth/JQL)."; return 1; }

    # Verify it's a JSON array
    jq -e 'type=="array"' "$tmp" >/dev/null 2>&1 || {
        echo "Unexpected output (not a JSON array)."
        return 1
    }

    # Build TSV rows for fzf: key, status, type, assignee, fixVersions, summary, desc-snippet
    local selected_key
    selected_key="$(
    jq -r '
      .[]
      | [
          .key,
          (.fields.summary // ""),
          (.fields.status.name // ""),
          (.fields.assignee.displayName // "Unassigned"),
          (.fields.issueType.name // ""),
          ((.fields.fixVersions // []) | map(.name) | join("; ")),
          ((.fields.description // "") | tostring | gsub("[\r\n\t]+";" ") | .[0:200])
        ]
      | @tsv
    ' "$tmp" \
    | fzf --height 90% --reverse --cycle \
          --prompt='jira> ' \
          ${initial:+--query="$initial"} \
          --delimiter=$'\t' --with-nth=1,2,3,4,5,6 \
          --preview-window=right:40%:wrap \
          --preview "
    k=\$(printf '%s' {} | cut -f1)
    jq -r --arg k \"\$k\" '
              .[] | select(.key==\$k)
              | \"\(.key)  [\(.fields.status.name // \"\")]  \(.fields.issueType.name // \"\")\n\"
                + \"Assignee: \(.fields.assignee.displayName // \"Unassigned\")\n\"
                + \"FixVersion: \(((.fields.fixVersions // []) | map(.name) | join(\", \")) // \"\")\n\"
                + \"Priority: \(.fields.priority.name // \"\")\n\"
                + \"Updated: \(.fields.updated // \"\")\n\"
                + \"\nSummary:\n\(.fields.summary // \"\")\n\"
                + \"\nDescription:\n\((.fields.description // \"\") | tostring)\n\"
            ' '$tmp' 2>/dev/null || jira issue view \"\$k\" 2>/dev/null
    " \
    | cut -f1
  )"

    [[ -n "$selected_key" ]] && printf '%s\n' "$selected_key"
}

# motd
# fortune -s | cowsay -n -f tux | lolcat
(printf '\n%.0s' {1..2}; if [ $((RANDOM % 10)) -eq 0 ]; then pokemon-colorscripts -r 1-3 -s --no-title; else pokemon-colorscripts -r 1-3 --no-title; fi) | sed 's/^/        /'
fortune -s | sed 's/^/  /'
